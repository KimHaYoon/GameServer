[9장]

분산 처리
장점 : 용량, 성능
단점 : 사후 관리성

클라이언트		서버
클라이언트------->	서버프로그래밍
클라이언트------->	

성능 높이는 방법 : 좋은 하드웨어를 사용, 하지만 이방법은 한계가 있다. -> scale up
그래서 나온 것이 scale out(하나의 성능을 올리는 것이 아니라, 똑같은 성능을 가지고 있는 PC들을 연결해서 서비스)

프로그램의 성능을 개선 : 최적화 -> 프로그래머가 괴로워짐

각각의 처리해야할 데이터를 쪼개거나
작업을 단계별로 쪼개거나.

로직처리 분산방식
1. 동기 분산 처리
2. 비동기 분산 처리
3. 데이터 복제 및 로컬 처리


여러 플레이어가 동시에 한 몬스터를 때리면 데이터 레이스가 발생한다.
그래서 lock을 걸고 때려야한다.
lock을 걸기 시작하면 오버헤드가 엄청나게 커진다.

실제 작업이 분산되면서 실행시간이 줄어들긴 하지만 오버헤드는 줄어들지 않은 상태로 증가한다.
scale out을 8배를 하면 8배가 빨라져야하는데 오버헤드 때문에 그러지 못한다.

lock()과 wait()를 비동기 방식으로 최소화

비동기 분산 처리
서버 1은 어떤 연산 명령을 다른 서버2에 송신, 서버 1은 서버 2의 명령 처리 결과를 기다리지 않음
그리고 일방적으로 자기가 해야하는 다음 일을 시작
그렇게된다면 wait()가 사라진다.

그렇기 때문에 비동기 분산 처리 방식의 성능이 높을 수 밖에 없다.

장점 : 잠금으로 인한 병목이 없으므로 각 서버가 가진 성능을 최대한으로 활용할 수 있다.
단점 : 모든 로직을 이 방식으로 구현하기 어렵거나 불가능하다. -> 프로그램이 복잡해진다.
        이 방식으로 프로그래밍을 할 때는 요청에 대한 응답을 기다리는 과정이 없기 때문에 반환값을 주고 받을 수가 없다.
        그 대신에 다음 방식으로 구현해야한다. (서로 일방적인 통보를 주고 받아야 한다.)
	-> 한쪽에서 저쪽으로 명령을 보낸다. 저쪽에서 이쪽으로 명령을 또 보낸다

패킷을 만들기 위해서 메모리도 사용해야하고 어쩌고 저쩌고해서 배보다 배꼽이 더 클 수가 있다.
-> 과도하게 서버간 분산 처리를 하면 쓸데없이 비효율적인 상황이 발생할 수 있음을 알 수 있다.

데이터 복제에 기반을 둔 로컬처리
부하가 일어나서 몬스터를 다른 곳에 넘겨 주었더니 왔다갔다하면서 오버헤드가 증가하였다. 이런 상황에서 해결책은 "몬스터를 복제하는 것"이다.
복사본을 중복으로 가지고 있는것
이것이 왜 분산 처리이냐, 데이터를 복제하여 데이터 복제를 왔다갔다하면서 오버헤드가 증가할 수있지 않냐?
하지만 각각 서버에서 하나의 서버의 몬스터들은 관심이 있는 몬스터의 정보만 복제를 하고 다른 서버에서는 모든 몬스터를 가지고 있어서 
관심이 있는 몬스터와의 상호작용 연산을 하기만 하면되서 모든 몬스터를 가지고 있는 하나의 서버보다 비교적 부하가 적다.
-> 부하분산도 되고, 성능도 상승
원본이 아닌 복사본 : 프록시

한서버에 있으면 괜찮은데 각각 다른 서버가 있다면 그 서버 사이에 통신이 필요하기 때문에 오버헤드가 발생
근데 응집도에 따라 다르다?

이동을 하면서 근처의 서버에 프록시가 생성이 되고 원본과 프록시의 정체성이 변경이 된다.

기능적 분산 처리  혹은 수직 분산 처리
수직 분산 처리는 데이터 단위 분산 처리, 즉 수평 분산 처리를 할 수 없을 때 선택할 수 있는 대안으로, 대표적인 예가 경매장 시스템
장점 : 구현이 쉽다 -> 통신 부분만 추가하면 됨
단점 : 적절한 부하 분산이 어렵다 -> 게임 서버와 경매장 서버는 여유가 있더라도 상대방의 작업을 대신할 수 없다.
        확장이 어렵다 -> 기능적 분산이 효과가 있을 만한 모듈들이 별로 없다.

어차피 경매장은 경매장 클래스로 생성되고 메소드 호출을 통해 관리가 되는데,
경매장 클래스를 지우고 메소드를 네트워크를 통해 호출한다.
당연하게도 비동기 방식을 사용해야 한다.

=> 기능적 분산이 가능하고 성능이나온다면 하지않을 이유는 없다. 분산 대상을 찾기 힘들 뿐이다.
	ex) AI서버, 인던서버, 경매서버, 채팅서버, DB서버, 보이스채팅(-> 부하가 큼)


분산 처리를 엄선해야하는 이유 : 지나친 분산 처리는 운영체제의 오버헤드를 증가시킨다. 
클라우드 서버 환경에서는 클라우드 서버 인스턴스 간에 통신 회선의 신뢰성도 문제가 될 수 있다.
분산 처리는 꼭 해야할 이유를 설명할 수 없다면 피하는 것이 좋다.
콘텐츠 업데이트나 시스템 업데이트가 계속 있어야 하는 게임 서버의 특성상 서버를 만드는 것도 중요하지만, 안정적인 서비스가 더 중요하기 때문
-> 듀랑고가 쓸데없이 분산처리 했다가 망했음

잘되면 좋음 -> 적은 비용으로 동접을 늘릴 수 있기 때문에

요약
분산 처리 전략
	성능 분석을 하여 분산 처리가 필요한 지점을 엄선한다.
	데이터 응집력을 확인한다. 다룰 데이터 간 상호작용이 높은 것은 분산하지 말고, 다룰 데이터 간 상호 작용이 매우 적은 것들만 골라서 분산한다.
	즉, 응집력이 높은 데이터를 구별하는 기준부터 찾아야한다.
	수평 분산 처리 방식은 동기 분산처리, 비동기 분산처리, 데이터 동기화에 기반을 둔 로컬 처리
				------------------------------------------------------> 둘을 적절히 섞어서 사용
	수평 분산 처리 자체는 구현과 디버깅이 까다롭고 불필요한 과부하를 일으킨다.
	불필요한 분산 처리라고 생각되는 부분은 피할 수 있으면 피하자

고가용성 (High Availability, HA) 
- 사용자가 항상 서비스를 이용할 수 있게 하는 것
- 서버가 고장 나거나 껏다 켜는 상황이 발생함에도 서버 역할을 지속하는 것
장애극복
- 서버 클러스터에 있는 서버 중 하나가 죽었을 때, 다른 서버가 죽은 서버를 대신해서 일을 하고 그동안 죽은 서버가 다시 살아나는 것
- 극복을 위해서 필요 이상의 서버를 두는 것을 이중화 or 다중화라고 한다.
	
고가용성을 위한 서버 구성 패턴
- 액티브-패시브(active-passive)패턴 : 마스터-슬레이브(master-slave)패턴이라고도 하며, 액티브 서버와 패시브 서버를 가짐
- 서버 한 대만 액티브 역할을 수행하고 나머지 서버는 패시브 모드로 대기하다가 액티브 서버가 죽으면 패시브가 그 역할을 대행한다.
- 패시브 서버는 그저 백업 역할만 할 뿐 다른 하는 일이 없는 서버 자원의 낭비가 생긴다.
-> 미러링(Mirroring)이 더 표준적이 용어이다.

액티브-액티브패턴 : 양방향 동기화
데이터 스테일 문제의 해결책 : 메모리 저장 서버를 놓는다 -> 메모리 저장 서버가 날라가면 큰일나는 문제
고가용성을 위한 메모리 저장소 서버의 이중화 : 메모리 저장 서버를 두개를 놓으면 된다. 둘 중 하나만 날라가도 상관 없음


데이터 베이스 분산
파티셔닝 : 더 많은 사용자를 처리하고자 데이터베이스가 수평확장을 할 때는 갖고 있는 레코드를 서로 다른 데이터 베이스에 나누어 놓는다
	-> 사용자를 나누는것 ㄱ~ㅇ은 1번 디비에 나머지는 2번디비에
	-> 단점 : 원하는 정보를 찾기위해서는 모든 디비를 뒤져야한다.

수직 파티셔닝 : 
	-> 단점 : 아이템 테이블은 큰데 나머지 테이블은 작다. -> 테이블의 크기가 균일하지 않다.
	-> 장점 : 원하는 정보를 찾기위해서는 그 해당하는 정보의 분류에서 뒤지면된다.

이중화 : 같은 내용의 레코드를 서버 두 대 이상에 저장
이렇게 하면 불필요한 자원 낭비로 보일 수 있지만, 그 대가로 고가용성을 얻는다.
특히 디비는 게임서버보다 고가용성이 더 요구되기도 한다.

[10장]

로그온 처리
1. 클라이언트는 서버에 ID와 비밀번호를 보낸다. 물론 암호화해서 보낸다.
2. 로그온 담당 서버(인증 서버)에서 이 메시지를 받고 메시지를 복호화한다.
3. 서버는 복호화된 메시지에서 ID와 비밀번호를 구한다. 그리고 DB에 질의를 던지고 나간다.

데이터 단위 분산하기
인증 서버를 서버 기기 여러 대로 수평확장한다.

로드 밸런서(load balancer)
가장 안바쁜 인증서버에서 하는 건데, 각각의 인증서버에 바쁘냐고 물어봐야하는데 이것은 엄청난 오버헤드이다.

모바일 게임은 L4-Switch사용

리해쉬(rehash)
데이터 베이스가 줄어들거나 늘어나면 해쉬 함수 값이 바뀌어야한다. 
정책을 바꾸어 바뀐 해쉬값에 맞추어 데이터를 옮겨줘야한다
그래서 오버헤드가 크다

데이터베이스의 수평확장
로그인을 담당하는 서버가 분산처리된 형태
- 로그인 서버, 매핑 DB서버 샤드, 플레이어 정보를 담은 DB서버 샤드

로그인 서버(서버에 인증 정보를 전달하는 방법)
암호를 가지고 서버에 접속을 해라,
서버는 암호를 가지고 인증된 사람인지 아닌지 판별

매치메이킹(matchmaking)
비슷한 실력의 유저끼리 모아서 게임을 할 수 있게 하는것
레벨이나 실력이 비슷한 유저끼리 응집도를 이룸
로비서버를 만들어 줘야한다.
성립 조건
1. 나는 지금 매칭을 기다리고 있습니다.
2. 너는 지금 매칭을 기다리고 있습니다.	-> 이러한 매칭 성립조건을 완료된 유저끼리 매칭을 해준다.
3. 너와 내 실력은 비슷합니다.

로비서버
작동
1. 플레이어 정보 목록을 서로 동기화한다. 
2. 매치메이킹
3.
작동 조건?
1. 
2.
3.

배틀서버 : 한 게임방 안에서 플레이들은 잦은 상호작용을 한다. 같은 방에 있는 플레이어끼리 응집력이 높다.
클라이언트는 로비서버에서 게임 시작 시 배틀 서버로 넘어간다.
근처에 있는 애들끼리 매치메이킹을 해준다.

몬스터 NPC처리의 분산 처리
서버에서 하는 몬스터 관련 처리

몬스터 데미지 연산, 플레이어 보상 연산하는데 300클록 사이클도 아까워서 NPC서버로 옮겼다. 근데 2000사이클 x 2이라 더 비효율적이다.
최적화를 신경써서 해야한다.

의미있는 분산 처리를 하려면 먼저 성능 분석을 하고, 오버헤드가 얼마나 차지하나 계산을 해야한다.

플레이어 간 상호 작용 분산처리
상호작용할 일이 없는 플레이들을 분산하는 것이 최선이다. -> 지역적 분산 처리를 하는 것

로그 및 통계 분석의 분산 처리
사냥터를 설계하거나 업데이트할 때 필요함

게임서버가 로그를 직접 디비에 삽입하는 것이아니라 로그서버에 전달해서 로그서버에서 로그 디비로 연결하여 삽입한다.
로그디비랑 게임디비랑 나눠야한다. 

로그서버가 죽는다고 게임서버가 죽는것이 아니기 때문에 미러링이 필요할까?
요러한 기법을 저널링이라고 부른다.



