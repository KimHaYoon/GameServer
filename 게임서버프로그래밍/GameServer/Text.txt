중간 20% 기말 25% 숙제 15% 턴프로젝트 30% 출석 10%

======================================================================
																	190904
======================================================================
CH1. 멀티스레드 프로그래밍

프로그램 ---실행---> 프로세스 (운영체제가 관리)
스레드 (= context) : 프로세스를 이루는 구성요소? 
Context : 실행 문맥, 맥락
	-> CPU 내부 상태

프로그램 1000개 작업이 있을 때 멀티스레드 프로그래밍은 1000개의 작업을 두개의 작업으로 나눈다.
-> 500개 작업씩 2개 (thread1, thread2)
멀티스레드 프로그램 -> 작업을 나누어서 별도의 여러개 스레드, 코어에서 수정

프로그램을 2개를 만들어서 할 때 통신 및 동기화가 필요없다면 그렇게해도 무관하지만 자원을 주고받는다면
통신, 동기화 과정이 꼭 필요하다.

IPC (Inter Procsess Communication)

Process
segmentation -> segment
code : 기계어 실행코드
data : 전역변수
heap : 동적할당 (new delete, malloc free)
stack : 지역변수, 함수, 함수파라미터

멀티 스레드일 때
thread0						|					thread1
code							|					X
data							|					X
heap							|					X
stack0						|					stack1

0번 스레드가 동적할당을 했을 때 1번스레드에서는 그 동적할당 한 자원을 아예 쓸 수 없는 것이 아니라 주소를 알면 쓸 수 있다.
스택에 있는 데이터는 공유를 할 수없다. 함수를 호출하면 지역변수가 생성이되는데 함수를 리턴하면 지역변수는 날아간다.
그렇기 때문에 공유가 되면 읽고 쓰던 데이터가 날라갈 수 있는 위험성이 있기 때문에 공유자체를 하면 안된다.

동시접속자 수가 1000명밖에 안되는 이유는 게임서버가 느려서
1. 잘못된 자료구조, 알고리즘을 사용하여 -> 좋은 자료구조, 알고리즘으로 대체
2. I/O 작업을 해서 -> 좋은 하드웨어를 산다, I/O 데이터 량을 줄이거나 횟수를 줄인다, 비동기

CPU가 느리면 잘 짠 서버를 실행해도 느리다.

1. 큰작업, 작은 작업 나눠서
2. 여러가지 작업들은 메모리? 
3. 멀티 스레드
4. 보기쉽게(OUP)? 먼말이냐 이건

Thread
1. Kernel level thread
	-> OS 관리
2. User level thread
	-> program 자체 관리

운영체제를 통해서
- window.h
 create thread				=> 너무 오래된 방식

--> 현재는 C++ 11를 통하여 생성

#include <thread>
std::thread 라는 클래스가 있는데 이 클래스의 객체를 만드는 것이 스레드를 생성하는 것
main()
{
	std::thread t1{함수포인터};
	std::thread t2;
}

운영체제
멀티 프로세서
동기화
	올바른 동기화를 위해서는 lock(), unlock(), 세마코어, 모니터, 데드락 등등이 필요하다
										------------
										#include <matrix> std::matrix my_lock
										my_lock.lock()
	



======================================================================
																	190905
======================================================================
1. 멀티쓰레드
게임서버
- 정확성 ->  NO BUG
- 성능	-> 렉이 없다
			-> 빠른 반응					
			=> 성능을 높히려면 멀티쓰레드를 사용해야한다.

2. 네트워크
게임 서버 : 온라인 게임 서버
					-> Network
					-> 넷기초 - 넷겜플 - 겜서버프로그래밍

3. 네트워크 프로그래밍
네트워크 기초
								서버	---		클라이언트
리소스를 가지고 있음						리소스를 요청하는 쪽				리소스를 서로 주고 받으면서 네트워크 프로그래밍 활동을 함	

OSI 7계층 X
TCP/IP 프로토콜 -> 4계층 
어플리케이션 레이어

4. 컴퓨터 네트워크 데이터
FILE I/O 
- C 
	- open - read, write - close

Network -> I/O
* I/O의 특징 : 운영체제가 관리 
- FILE I/O와 거의 유사
	- connet - send, recv - close

3번 보낸다고 3번 맞춰서 받아주지는 않는다.
전달되는 순서는 반드시 지켜지는데 묶어서 보내든 풀어서 보내든 랜덤으로 보낸다.

네트워크 데이터의 양을 고려해서 서버를 설계해야한다.
데이터를 조금씩 보내면 처리해야할 데이터의 크기가 작아서 처리가 빨리 되기 때문에 성능이 향상이 된다.
그때 고려해야할 방식을 헤더 방식
ex) 100byte를 보낼 때 100byte를 한번에 보내던지 10byte씩 10번 보내던지 두가지의 방법이 있다면 10byte씩 10번 보내는 것이 네트워크 성능이 향상될 수 있다.
		? 데이터를 한방에 보낼 때 여러번 자주 보내는 것 보다 좋다. 

메세지 형식
클라이언트 -------------> 서버														-- 디비
이동방향									채팅 (누구한테, 뭐라고)
공격											다음 위치, 공격후 상태	(스킬? 등등)
채팅											인벤토리	

네트워크로 주고 받는 것은 2진수 이다. byte
총알의 발사된 위치 종류 등등 알려줘야한다. 그래서 맨앞에 타입이 들어가야하고 크기가 들어가야 한다.
데이터 묶음 하나하나를 패킷이라고 부른다.

단편화 : 매우 긴 스트림을 송신 할 때 운영체제에서 이를 IP 패킷의 크기 제한에 맞추어 여러 조각을 내는 것
-> 스트림을 패킷으로 조각내고 패킷을 다시 스트림으로 복원


======================================================================
																	190911
======================================================================
1.3 멀티스레드 프로그래밍은 언제 해야할까?
멀티스레드 프로그래밍을 해야하는 대표적인 상황
1. 오래걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야할 때 
- X
- 이유 : 짧은 작업의 종료시간이 뒤로 밀리는 경우
- 차라리 오래 걸리는 일을 쪼개서 처리해야 한다.
2. 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
- X
- 이유 : 짧은 작업의 반응 속도가 떨어지는 경우
- 차라리 오래 걸리는 일을 쪼개서 처리해야 한다.
- 30만명이 동시 접속을 한다면 초당 1만 번밖에 처리를 하지 못하는 상황이 발생
	-> 비동기 I/O or Overlapped I/O으로 처리해야 함
3. 기기에 있는 CPU(Core)를 모두 활용해야 할 때
4. 프로그램을 모듈화 하여 다른 쓰레드에서 독립적으로 실행
- X
- 이유 : Readability, Object Oriented
- 부작용이 너무 크다
* Single Core의 사용량이 100%가 되지 않았다면 멀티 쓰레드 프로그래밍을 절대로 하면 안된다.

뮤텍스 : 상호배제, 임계영역
lock, unlock
내가 읽고 쓰는 값을 다른애가 건들지 못하게 할 때에는 lock 그 값을 다 사용한 뒤에는 unlock을 사용하면 스레드끼리 겹치지않게 값을 건든다.

lock_guard를 해주면 객체가 생성될 때 lock을 해주고 소멸할 때 unlock을 자동으로 해준다.
-> 코드블럭에서 자동으로 lock, unlock 

lock을 건다음에 또 lock을 걸면 deadlock상태에 빠진다.
lock을 건 횟수만큼 unlock을 해줘야 다른 스레드가 접근이 가능하다.
* 주의사항
 - 뮤텍스를 너무 잘게 나누면 뮤텍스를 액세스하는 과정 자체가 무겁기 때문에 프로그램의 성능이 떨어진다.
   또한 프로그램이 매우 복잡해져 교착상태(dead lock)문제가 쉽게 발생 할 수 있다.

크리티컬 섹션은 옛날 코드임. mutex로 사용~

dead lock의 네가지 조건
https://blog.naver.com/jsj776655/60163306675
1. 상호 배제
2. 점유하며 대기
3. 비선점
4. 순환 대기

dead lock 방지법
https://blog.naver.com/jsj776655/60163310441

암달의 법칙, 암달의 저주 : 시리얼 병목이 있을 때, CPU개수가 많을수록 총 처리 효율성이 떨어지는 현상