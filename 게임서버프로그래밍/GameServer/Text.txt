중간 20% 기말 25% 숙제 15% 턴프로젝트 30% 출석 10%

======================================================================
							190904
======================================================================
CH1. 멀티스레드 프로그래밍

프로그램 ---실행---> 프로세스 (운영체제가 관리)
스레드 (= context) : 프로세스를 이루는 구성요소? 
Context : 실행 문맥, 맥락
	-> CPU 내부 상태

프로그램 1000개 작업이 있을 때 멀티스레드 프로그래밍은 1000개의 작업을 두개의 작업으로 나눈다.
-> 500개 작업씩 2개 (thread1, thread2)
멀티스레드 프로그램 -> 작업을 나누어서 별도의 여러개 스레드, 코어에서 수정

프로그램을 2개를 만들어서 할 때 통신 및 동기화가 필요없다면 그렇게해도 무관하지만 자원을 주고받는다면
통신, 동기화 과정이 꼭 필요하다.

IPC (Inter Procsess Communication)

Process
segmentation -> segment
code : 기계어 실행코드
data : 전역변수
heap : 동적할당 (new delete, malloc free)
stack : 지역변수, 함수, 함수파라미터

멀티 스레드일 때
thread0						|					thread1
code							|					X
data							|					X
heap							|					X
stack0						|					stack1

0번 스레드가 동적할당을 했을 때 1번스레드에서는 그 동적할당 한 자원을 아예 쓸 수 없는 것이 아니라 주소를 알면 쓸 수 있다.
스택에 있는 데이터는 공유를 할 수없다. 함수를 호출하면 지역변수가 생성이되는데 함수를 리턴하면 지역변수는 날아간다.
그렇기 때문에 공유가 되면 읽고 쓰던 데이터가 날라갈 수 있는 위험성이 있기 때문에 공유자체를 하면 안된다.

동시접속자 수가 1000명밖에 안되는 이유는 게임서버가 느려서
1. 잘못된 자료구조, 알고리즘을 사용하여 -> 좋은 자료구조, 알고리즘으로 대체
2. I/O 작업을 해서 -> 좋은 하드웨어를 산다, I/O 데이터 량을 줄이거나 횟수를 줄인다, 비동기

CPU가 느리면 잘 짠 서버를 실행해도 느리다.

1. 큰작업, 작은 작업 나눠서
2. 여러가지 작업들은 메모리? 
3. 멀티 스레드
4. 보기쉽게(OUP)? 먼말이냐 이건

Thread
1. Kernel level thread
	-> OS 관리
2. User level thread
	-> program 자체 관리

운영체제를 통해서
- window.h
 create thread				=> 너무 오래된 방식

--> 현재는 C++ 11를 통하여 생성

#include <thread>
std::thread 라는 클래스가 있는데 이 클래스의 객체를 만드는 것이 스레드를 생성하는 것
main()
{
	std::thread t1{함수포인터};
	std::thread t2;
}

운영체제
멀티 프로세서
동기화
	올바른 동기화를 위해서는 lock(), unlock(), 세마코어, 모니터, 데드락 등등이 필요하다
										------------
										#include <matrix> std::matrix my_lock
										my_lock.lock()
	



======================================================================
							190905
======================================================================
1. 멀티쓰레드
게임서버
- 정확성 ->  NO BUG
- 성능	-> 렉이 없다
			-> 빠른 반응					
			=> 성능을 높히려면 멀티쓰레드를 사용해야한다.

2. 네트워크
게임 서버 : 온라인 게임 서버
					-> Network
					-> 넷기초 - 넷겜플 - 겜서버프로그래밍

3. 네트워크 프로그래밍
네트워크 기초
								서버	---		클라이언트
리소스를 가지고 있음						리소스를 요청하는 쪽				리소스를 서로 주고 받으면서 네트워크 프로그래밍 활동을 함	

OSI 7계층 X
TCP/IP 프로토콜 -> 4계층 
어플리케이션 레이어

4. 컴퓨터 네트워크 데이터
FILE I/O 
- C 
	- open - read, write - close

Network -> I/O
* I/O의 특징 : 운영체제가 관리 
- FILE I/O와 거의 유사
	- connet - send, recv - close

3번 보낸다고 3번 맞춰서 받아주지는 않는다.
전달되는 순서는 반드시 지켜지는데 묶어서 보내든 풀어서 보내든 랜덤으로 보낸다.

네트워크 데이터의 양을 고려해서 서버를 설계해야한다.
데이터를 조금씩 보내면 처리해야할 데이터의 크기가 작아서 처리가 빨리 되기 때문에 성능이 향상이 된다.
그때 고려해야할 방식을 헤더 방식
ex) 100byte를 보낼 때 100byte를 한번에 보내던지 10byte씩 10번 보내던지 두가지의 방법이 있다면 10byte씩 10번 보내는 것이 네트워크 성능이 향상될 수 있다.
		? 데이터를 한방에 보낼 때 여러번 자주 보내는 것 보다 좋다. 

메세지 형식
클라이언트 -------------> 서버														-- 디비
이동방향									채팅 (누구한테, 뭐라고)
공격											다음 위치, 공격후 상태	(스킬? 등등)
채팅											인벤토리	

네트워크로 주고 받는 것은 2진수 이다. byte
총알의 발사된 위치 종류 등등 알려줘야한다. 그래서 맨앞에 타입이 들어가야하고 크기가 들어가야 한다.
데이터 묶음 하나하나를 패킷이라고 부른다.

단편화 : 매우 긴 스트림을 송신 할 때 운영체제에서 이를 IP 패킷의 크기 제한에 맞추어 여러 조각을 내는 것
-> 스트림을 패킷으로 조각내고 패킷을 다시 스트림으로 복원


======================================================================
							190911
======================================================================
1.3 멀티스레드 프로그래밍은 언제 해야할까?
멀티스레드 프로그래밍을 해야하는 대표적인 상황
1. 오래걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야할 때 
- X
- 이유 : 짧은 작업의 종료시간이 뒤로 밀리는 경우
- 차라리 오래 걸리는 일을 쪼개서 처리해야 한다.
2. 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
- X
- 이유 : 짧은 작업의 반응 속도가 떨어지는 경우
- 차라리 오래 걸리는 일을 쪼개서 처리해야 한다.
- 30만명이 동시 접속을 한다면 초당 1만 번밖에 처리를 하지 못하는 상황이 발생
	-> 비동기 I/O or Overlapped I/O으로 처리해야 함
3. 기기에 있는 CPU(Core)를 모두 활용해야 할 때
4. 프로그램을 모듈화 하여 다른 쓰레드에서 독립적으로 실행
- X
- 이유 : Readability, Object Oriented
- 부작용이 너무 크다
* Single Core의 사용량이 100%가 되지 않았다면 멀티 쓰레드 프로그래밍을 절대로 하면 안된다.

뮤텍스 : 상호배제, 임계영역
lock, unlock
내가 읽고 쓰는 값을 다른애가 건들지 못하게 할 때에는 lock 그 값을 다 사용한 뒤에는 unlock을 사용하면 스레드끼리 겹치지않게 값을 건든다.

lock_guard를 해주면 객체가 생성될 때 lock을 해주고 소멸할 때 unlock을 자동으로 해준다.
-> 코드블럭에서 자동으로 lock, unlock 

lock을 건다음에 또 lock을 걸면 deadlock상태에 빠진다.
lock을 건 횟수만큼 unlock을 해줘야 다른 스레드가 접근이 가능하다.
* 주의사항
 - 뮤텍스를 너무 잘게 나누면 뮤텍스를 액세스하는 과정 자체가 무겁기 때문에 프로그램의 성능이 떨어진다.
   또한 프로그램이 매우 복잡해져 교착상태(dead lock)문제가 쉽게 발생 할 수 있다.

크리티컬 섹션은 옛날 코드임. mutex로 사용~

dead lock의 네가지 조건
https://blog.naver.com/jsj776655/60163306675
1. 상호 배제
2. 점유하며 대기
3. 비선점
4. 순환 대기

dead lock 방지법
https://blog.naver.com/jsj776655/60163310441

암달의 법칙, 암달의 저주 : 시리얼 병목이 있을 때, CPU개수가 많을수록 총 처리 효율성이 떨어지는 현상

======================================================================
							190918
======================================================================

비쥬얼은 스레드를 만들 때 보조 스레드를 생성한다. 이것은 비쥬얼이 만든 것이므로 알아서 죽는다. 신경쓸 필요 X

프로파일러 : 프로그램의 실행 패턴을 분석하여 어디가 낭비인지 밝히는 프로그램
	-> Concurrency Visualizer 

메인스레드는 동기화때문에 아무것도 하지 못하낟
워커스레드는 선점? 
스레드를 추가하면 추가할 수록 낭비가 커진다.

게임서버의 종류 : MMO, 

MMO
- 방이 없고, 모든 플레이어가 같은 방에서 플레이한다.
- 동접으로 통계를 냄

코어 4개가 돌아가고 있으면 스레드가 5개가 있으면 하나는 딜레이가된다.

콘텍스트 스위칭 때문에 시간이 낭비되고 실행되지 못하는 스레드가 생기고 딜레이가 생긴다. 성능이 저하된다.
따라서 코어의 개수에 맞춰서 스레드를 생성해야한다.

네트워크 I/O
스레드가 실행하다가 멈추면 논다.

======================================================================
							190919
======================================================================

MMOGameServer
1. network 프로그래밍
2. 멀티스레드 프로그래밍

하나의 LAN에는 연결할 수 있는 컴퓨터의 대수가 제한되어 있다.

데이터는 최소한 간략하게 보내야함.
-> 데이터 그 자체를 최대한 압축하여 보내야 함

인터넷은 8비트가 4개 = 32비트 = 4바이트
전세계에서 연결될 수 있는 컴퓨터 대수 : 40억대 정도

앱스토어에서는 IPv6버전으로 짜야만 앱을 받아줌

메모리 CPU는 다 연속적인 값이다.
-> 오류에 취약 ex) 노이즈
노이즈가 많으면 데이터 전송이 느려진다
-> 데이터 변경이 일어나면 그 데이터를 버리고 재전송하기 때문에

인터넷 프로토콜 = TCP/IP 프로토콜

TCP
- UDP와는 달리 데이터 유실이 적음
- 안전한 데이터 전송 보장
UDP - 우편엽서 보내는 것
UDP는 데이터 유실이나 순서 뒤바뀜, 중복 수신 현상이 발생해도 신경안쓴다.
- 오버헤드가 없어서 많이 사용한다.
- ex) FPS에서 무브패킷을 보낼 때 사용한다.

======================================================================
							190925
======================================================================
* 인터넷 통신 API
1. UDP
- 순서 X
- 유실 가능
	-> 패킷 유실이 발생하면 데이터그램이 유실된다.
	-> UDP의 레이턴시 = 네트워크 기기의 레이턴시
		-> UDP는 주로 레이턴시가 민감하거나 패킷 유실이 있어도 괜찮은 곳에서 주로 사용한다.
			-> ex) 캐릭터 이동, 기관총 난사, 음성이나 화상 데이터 전송, 대전 격투 게임, 실시간 전략 시뮬레이선 게임(RTS)
			-> 적절한 보간처리를 하기 때문에 ㄱㅊ						----------------------------------------------> TCP를 사용할 때도 있음

2. TCP
- 순서 O
	-> 과거에 뭘 보냈는가 쭉 기록을 해야 함
	-> 송신
		-> connect()로 연결을 해놓고 그 연결한 곳에다가 send()로 정보를 보낸다.
		-> sendTo()함수를 사용하지 않는 이유 : connect()함수로 연결 끝 점을 지정하였기 때문에
		-> 송신을 하고 난뒤에 소켓을 close()해주면 연결이 끝남
	-> 수신
		-> accept()를 실행하면 상대방에서 TCP연결을 받을 때까지 블로킹된다.
		-> 언젠가는 연결이 끊어지는데 그것을 어떻게 아냐면 recv()가 0byte를 수신하면 연결이 종료되었음을 알게되어서 마감처리를 해야한다.

- 유실 불가능
	-> 패킷 유실이 발생하면 중간에 지연 시간이 발생한다.
	-> TCP의 레이턴시 = 네트워크 기기의 레이턴시 + (100% - 패킷 유실률) * 재전송 대기 시간
		-> 패킷이 많이 유실될 수록 재전송 대기 시간은 길어짐
		-> 네트워크가 아주 나쁘지않는 한 패킷 유실률은 20%이하이지만, 재전송 대기 시간은 수백 밀리초 수준임
		-> 체감 레이턴시는 높은 편차 때문에 사용자에게 불쾌감을 주므로 중요한 데이터 송수신을 할 때에는 TCP를 사용
			-> ex) MMORPG : 행동 하나하나가 중요하기 때문에

* 주로 사용하는 메시지 형식
- 패킷 포맷 : 게임 플레이에서 사용되는 메시지 형식, 프로토콜을 맞춘다.
												-------> Protocol : 패킷 포맷과 순서, 약속임
- 어떤 방식으로 대화를 할지 정해야 한다. 
- 텍스트 형식의 메시지 : 사람이 읽을 수 있다.
	-> 단점 : 칼 하나를 사는 간단한 동작인데 메시지 바이트가 17byte나 데이터를 보내야 함,
			  비교를 해야하고, 1이라는 아스키 코드를 0x0001로 바꿔야 한다.
			  부하가 크다.
	-> 장점 : 사람이 읽을 수 있기 때문에 디버깅하기 쉽고 에러가 나도 어디서 에러인지 알아차리기 쉽다.
	-> ex) 애니팡 같은 모바일 게임들
- 바이너리 형식의 메시지 : 사람이 읽기 어렵다.
	-> 장점 : 17byte인 데이터가 5byte로 단축이 됨,
			  메모리 서치하는 행동이 필요 없음. 성능이 향상
			  번역 오버헤딩이 필요없다?
	-> 단점 : 사람이 읽기 어렵기 때문. 기계어이기 때문에,디버깅 하기가 어렵고 어디서 에러인지 알아차리기가 어렵다.
	-> 바이너리 형식으로도 메타데이터를 포함시킬 수 있다.
	-> 우리는 이런 형식을 사용해야한다. 성능이 중요하기 때문에
	-> MMORPG에서 사용
- 메타 데이터가 없는 형식
	-> 장점 : 사람이 알아보기 쉽고 가독성 ↑
	-> 단점 : 오동작을 일으키기 쉽다.
- 메타 데이터가 있는 형식
	-> 한 번에 어떤 것인지 알기 쉽게 설명을 덧붙여서 보내는 형식	
								   ---> = 메타 데이터
	-> 장점 : 오동작을 일으키지 않는다, 하위 호환성 측면에서 유리하다.
	-> 단점 : 데이터의 크기가 더 커진다, 사용자의 편의성과 성능을 뒤바꾼다.
	-> 모바일앱에서는 메타 데이터 방식이 유리 : 대부분의 모바일앱의 서버는 웹서버 시스템을 사용하기도 함

** 오버헤드 (overhead) : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등

* 네트워크 주소 변환
우리가 인터넷을 통해서 데이터를 주고 받을 때 
클라이언트 ----------------------- 서버
		  connect(32bit 주소 정보)
					-> 컴퓨터가 40억대 이상은 연결할 수 없다. 
					하지만 지금은 60억대 이상 연결되어 있어서 IPv6가 개발됨
- 공유기(NAT 라우터) : IP주소 하나를 여러대의 기기가 연결될 수 있도록 만들어 주는 역할
	-> 129.7.5.1 : 포트번호
		-> 해당하는 포트 번호에 전달을 해주는 역할을 라우터가 함
	-> NAT : network address translation
	-> 192.168.0.5 라우터 내의 연결된 기기의 IP주소? 전세계에서 이런 번호를 수십만대 이상이 사용 꼼수임.
	-> 맨 끝단에 있는 공유기의 주소를 알아야하는데 이것을 알아내기가 어려움
	-> 서버를 내 집에서 띄우고 학교나 친구 집에서 접속을 하려면 굉장히 복잡한 절차가 필요하다.
	-> 서버를 공유기 밖으로 빼놓고 직접 접속해서 연결을 한다.
	-> 서버 대여업체에서 서버를 빌려쓴다...?
	

======================================================================
							191002
======================================================================
epoll -> connect와 accept에서도 I/O 기능을 사용 가능
요즘에 리눅스에서 쓰는 회사에서는 epoll대신 asio를 사용한다.

1:n서버 클라이언트가 아무때나 접속하고 아무때나 종료할 수있다.
클라이언트가 접속하는 즉시 accept한다.

서버가 클라이언트로 패킷을 한가지가 아니라 여러패킷(무브, 채팅, 이펙트)을 묶어서 보낼 때 어떻게 해야하나?
1. send를 3번
	-> 운영체제를 3번 호출해야하기 때문에 낭비이다.
	-> 버퍼를 크게 만들어 한 번에 보낸다.
		-> 메모리를 차지하고, 복사하느라고 시간이 많이 걸린다.
		-> 하지만 운영체제를 호출하는 것보다는 오버헤드가 덜걸린다. 
		-> 그렇지만 포인터를 참조하면 메모리 카피도 필요없어서 굉장히 효율적이다.


RIO -> 잘 사용한다면 IOCP보다는 성능이 더 좋을 수도

======================================================================
							191009
======================================================================
IOCP는 성능 때문에 쓰는 것인데 멀티 스레드를 사용하는 것이 좋다.
