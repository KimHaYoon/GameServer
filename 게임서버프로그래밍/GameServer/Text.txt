중간 20% 기말 25% 숙제 15% 턴프로젝트 30% 출석 10%

======================================================================
							190904
======================================================================
CH1. 멀티스레드 프로그래밍

프로그램 ---실행---> 프로세스 (운영체제가 관리)
스레드 (= context) : 프로세스를 이루는 구성요소? 
Context : 실행 문맥, 맥락
	-> CPU 내부 상태

프로그램 1000개 작업이 있을 때 멀티스레드 프로그래밍은 1000개의 작업을 두개의 작업으로 나눈다.
-> 500개 작업씩 2개 (thread1, thread2)
멀티스레드 프로그램 -> 작업을 나누어서 별도의 여러개 스레드, 코어에서 수정

프로그램을 2개를 만들어서 할 때 통신 및 동기화가 필요없다면 그렇게해도 무관하지만 자원을 주고받는다면
통신, 동기화 과정이 꼭 필요하다.

IPC (Inter Procsess Communication)

Process
segmentation -> segment
code : 기계어 실행코드
data : 전역변수
heap : 동적할당 (new delete, malloc free)
stack : 지역변수, 함수, 함수파라미터

멀티 스레드일 때
thread0						|					thread1
code							|					X
data							|					X
heap							|					X
stack0						|					stack1

0번 스레드가 동적할당을 했을 때 1번스레드에서는 그 동적할당 한 자원을 아예 쓸 수 없는 것이 아니라 주소를 알면 쓸 수 있다.
스택에 있는 데이터는 공유를 할 수없다. 함수를 호출하면 지역변수가 생성이되는데 함수를 리턴하면 지역변수는 날아간다.
그렇기 때문에 공유가 되면 읽고 쓰던 데이터가 날라갈 수 있는 위험성이 있기 때문에 공유자체를 하면 안된다.

동시접속자 수가 1000명밖에 안되는 이유는 게임서버가 느려서
1. 잘못된 자료구조, 알고리즘을 사용하여 -> 좋은 자료구조, 알고리즘으로 대체
2. I/O 작업을 해서 -> 좋은 하드웨어를 산다, I/O 데이터 량을 줄이거나 횟수를 줄인다, 비동기

CPU가 느리면 잘 짠 서버를 실행해도 느리다.

1. 큰작업, 작은 작업 나눠서
2. 여러가지 작업들은 메모리? 
3. 멀티 스레드
4. 보기쉽게(OUP)? 먼말이냐 이건

Thread
1. Kernel level thread
	-> OS 관리
2. User level thread
	-> program 자체 관리

운영체제를 통해서
- window.h
 create thread				=> 너무 오래된 방식

--> 현재는 C++ 11를 통하여 생성

#include <thread>
std::thread 라는 클래스가 있는데 이 클래스의 객체를 만드는 것이 스레드를 생성하는 것
main()
{
	std::thread t1{함수포인터};
	std::thread t2;
}

운영체제
멀티 프로세서
동기화
	올바른 동기화를 위해서는 lock(), unlock(), 세마코어, 모니터, 데드락 등등이 필요하다
										------------
										#include <matrix> std::matrix my_lock
										my_lock.lock()
	



======================================================================
							190905
======================================================================
1. 멀티쓰레드
게임서버
- 정확성 ->  NO BUG
- 성능	-> 렉이 없다
			-> 빠른 반응					
			=> 성능을 높히려면 멀티쓰레드를 사용해야한다.

2. 네트워크
게임 서버 : 온라인 게임 서버
					-> Network
					-> 넷기초 - 넷겜플 - 겜서버프로그래밍

3. 네트워크 프로그래밍
네트워크 기초
								서버	---		클라이언트
리소스를 가지고 있음						리소스를 요청하는 쪽				리소스를 서로 주고 받으면서 네트워크 프로그래밍 활동을 함	

OSI 7계층 X
TCP/IP 프로토콜 -> 4계층 
어플리케이션 레이어

4. 컴퓨터 네트워크 데이터
FILE I/O 
- C 
	- open - read, write - close

Network -> I/O
* I/O의 특징 : 운영체제가 관리 
- FILE I/O와 거의 유사
	- connet - send, recv - close

3번 보낸다고 3번 맞춰서 받아주지는 않는다.
전달되는 순서는 반드시 지켜지는데 묶어서 보내든 풀어서 보내든 랜덤으로 보낸다.

네트워크 데이터의 양을 고려해서 서버를 설계해야한다.
데이터를 조금씩 보내면 처리해야할 데이터의 크기가 작아서 처리가 빨리 되기 때문에 성능이 향상이 된다.
그때 고려해야할 방식을 헤더 방식
ex) 100byte를 보낼 때 100byte를 한번에 보내던지 10byte씩 10번 보내던지 두가지의 방법이 있다면 10byte씩 10번 보내는 것이 네트워크 성능이 향상될 수 있다.
		? 데이터를 한방에 보낼 때 여러번 자주 보내는 것 보다 좋다. 

메세지 형식
클라이언트 -------------> 서버														-- 디비
이동방향									채팅 (누구한테, 뭐라고)
공격											다음 위치, 공격후 상태	(스킬? 등등)
채팅											인벤토리	

네트워크로 주고 받는 것은 2진수 이다. byte
총알의 발사된 위치 종류 등등 알려줘야한다. 그래서 맨앞에 타입이 들어가야하고 크기가 들어가야 한다.
데이터 묶음 하나하나를 패킷이라고 부른다.

단편화 : 매우 긴 스트림을 송신 할 때 운영체제에서 이를 IP 패킷의 크기 제한에 맞추어 여러 조각을 내는 것
-> 스트림을 패킷으로 조각내고 패킷을 다시 스트림으로 복원


======================================================================
							190911
======================================================================
1.3 멀티스레드 프로그래밍은 언제 해야할까?
멀티스레드 프로그래밍을 해야하는 대표적인 상황
1. 오래걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야할 때 
- X
- 이유 : 짧은 작업의 종료시간이 뒤로 밀리는 경우
- 차라리 오래 걸리는 일을 쪼개서 처리해야 한다.
2. 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
- X
- 이유 : 짧은 작업의 반응 속도가 떨어지는 경우
- 차라리 오래 걸리는 일을 쪼개서 처리해야 한다.
- 30만명이 동시 접속을 한다면 초당 1만 번밖에 처리를 하지 못하는 상황이 발생
	-> 비동기 I/O or Overlapped I/O으로 처리해야 함
3. 기기에 있는 CPU(Core)를 모두 활용해야 할 때
4. 프로그램을 모듈화 하여 다른 쓰레드에서 독립적으로 실행
- X
- 이유 : Readability, Object Oriented
- 부작용이 너무 크다
* Single Core의 사용량이 100%가 되지 않았다면 멀티 쓰레드 프로그래밍을 절대로 하면 안된다.

뮤텍스 : 상호배제, 임계영역
lock, unlock
내가 읽고 쓰는 값을 다른애가 건들지 못하게 할 때에는 lock 그 값을 다 사용한 뒤에는 unlock을 사용하면 스레드끼리 겹치지않게 값을 건든다.

lock_guard를 해주면 객체가 생성될 때 lock을 해주고 소멸할 때 unlock을 자동으로 해준다.
-> 코드블럭에서 자동으로 lock, unlock 

lock을 건다음에 또 lock을 걸면 deadlock상태에 빠진다.
lock을 건 횟수만큼 unlock을 해줘야 다른 스레드가 접근이 가능하다.
* 주의사항
 - 뮤텍스를 너무 잘게 나누면 뮤텍스를 액세스하는 과정 자체가 무겁기 때문에 프로그램의 성능이 떨어진다.
   또한 프로그램이 매우 복잡해져 교착상태(dead lock)문제가 쉽게 발생 할 수 있다.

크리티컬 섹션은 옛날 코드임. mutex로 사용~

dead lock의 네가지 조건
https://blog.naver.com/jsj776655/60163306675
1. 상호 배제
2. 점유하며 대기
3. 비선점
4. 순환 대기

dead lock 방지법
https://blog.naver.com/jsj776655/60163310441

암달의 법칙, 암달의 저주 : 시리얼 병목이 있을 때, CPU개수가 많을수록 총 처리 효율성이 떨어지는 현상

======================================================================
							190918
======================================================================

비쥬얼은 스레드를 만들 때 보조 스레드를 생성한다. 이것은 비쥬얼이 만든 것이므로 알아서 죽는다. 신경쓸 필요 X

프로파일러 : 프로그램의 실행 패턴을 분석하여 어디가 낭비인지 밝히는 프로그램
	-> Concurrency Visualizer 

메인스레드는 동기화때문에 아무것도 하지 못하낟
워커스레드는 선점? 
스레드를 추가하면 추가할 수록 낭비가 커진다.

게임서버의 종류 : MMO, 

MMO
- 방이 없고, 모든 플레이어가 같은 방에서 플레이한다.
- 동접으로 통계를 냄

코어 4개가 돌아가고 있으면 스레드가 5개가 있으면 하나는 딜레이가된다.

콘텍스트 스위칭 때문에 시간이 낭비되고 실행되지 못하는 스레드가 생기고 딜레이가 생긴다. 성능이 저하된다.
따라서 코어의 개수에 맞춰서 스레드를 생성해야한다.

네트워크 I/O
스레드가 실행하다가 멈추면 논다.

======================================================================
							190919
======================================================================

MMOGameServer
1. network 프로그래밍
2. 멀티스레드 프로그래밍

하나의 LAN에는 연결할 수 있는 컴퓨터의 대수가 제한되어 있다.

데이터는 최소한 간략하게 보내야함.
-> 데이터 그 자체를 최대한 압축하여 보내야 함

인터넷은 8비트가 4개 = 32비트 = 4바이트
전세계에서 연결될 수 있는 컴퓨터 대수 : 40억대 정도

앱스토어에서는 IPv6버전으로 짜야만 앱을 받아줌

메모리 CPU는 다 연속적인 값이다.
-> 오류에 취약 ex) 노이즈
노이즈가 많으면 데이터 전송이 느려진다
-> 데이터 변경이 일어나면 그 데이터를 버리고 재전송하기 때문에

인터넷 프로토콜 = TCP/IP 프로토콜

TCP
- UDP와는 달리 데이터 유실이 적음
- 안전한 데이터 전송 보장
UDP - 우편엽서 보내는 것
UDP는 데이터 유실이나 순서 뒤바뀜, 중복 수신 현상이 발생해도 신경안쓴다.
- 오버헤드가 없어서 많이 사용한다.
- ex) FPS에서 무브패킷을 보낼 때 사용한다.

======================================================================
							190925
======================================================================
* 인터넷 통신 API
1. UDP
- 순서 X
- 유실 가능
	-> 패킷 유실이 발생하면 데이터그램이 유실된다.
	-> UDP의 레이턴시 = 네트워크 기기의 레이턴시
		-> UDP는 주로 레이턴시가 민감하거나 패킷 유실이 있어도 괜찮은 곳에서 주로 사용한다.
			-> ex) 캐릭터 이동, 기관총 난사, 음성이나 화상 데이터 전송, 대전 격투 게임, 실시간 전략 시뮬레이선 게임(RTS)
			-> 적절한 보간처리를 하기 때문에 ㄱㅊ						----------------------------------------------> TCP를 사용할 때도 있음

2. TCP
- 순서 O
	-> 과거에 뭘 보냈는가 쭉 기록을 해야 함
	-> 송신
		-> connect()로 연결을 해놓고 그 연결한 곳에다가 send()로 정보를 보낸다.
		-> sendTo()함수를 사용하지 않는 이유 : connect()함수로 연결 끝 점을 지정하였기 때문에
		-> 송신을 하고 난뒤에 소켓을 close()해주면 연결이 끝남
	-> 수신
		-> accept()를 실행하면 상대방에서 TCP연결을 받을 때까지 블로킹된다.
		-> 언젠가는 연결이 끊어지는데 그것을 어떻게 아냐면 recv()가 0byte를 수신하면 연결이 종료되었음을 알게되어서 마감처리를 해야한다.

- 유실 불가능
	-> 패킷 유실이 발생하면 중간에 지연 시간이 발생한다.
	-> TCP의 레이턴시 = 네트워크 기기의 레이턴시 + (100% - 패킷 유실률) * 재전송 대기 시간
		-> 패킷이 많이 유실될 수록 재전송 대기 시간은 길어짐
		-> 네트워크가 아주 나쁘지않는 한 패킷 유실률은 20%이하이지만, 재전송 대기 시간은 수백 밀리초 수준임
		-> 체감 레이턴시는 높은 편차 때문에 사용자에게 불쾌감을 주므로 중요한 데이터 송수신을 할 때에는 TCP를 사용
			-> ex) MMORPG : 행동 하나하나가 중요하기 때문에

* 주로 사용하는 메시지 형식
- 패킷 포맷 : 게임 플레이에서 사용되는 메시지 형식, 프로토콜을 맞춘다.
												-------> Protocol : 패킷 포맷과 순서, 약속임
- 어떤 방식으로 대화를 할지 정해야 한다. 
- 텍스트 형식의 메시지 : 사람이 읽을 수 있다.
	-> 단점 : 칼 하나를 사는 간단한 동작인데 메시지 바이트가 17byte나 데이터를 보내야 함,
			  비교를 해야하고, 1이라는 아스키 코드를 0x0001로 바꿔야 한다.
			  부하가 크다.
	-> 장점 : 사람이 읽을 수 있기 때문에 디버깅하기 쉽고 에러가 나도 어디서 에러인지 알아차리기 쉽다.
	-> ex) 애니팡 같은 모바일 게임들
- 바이너리 형식의 메시지 : 사람이 읽기 어렵다.
	-> 장점 : 17byte인 데이터가 5byte로 단축이 됨,
			  메모리 서치하는 행동이 필요 없음. 성능이 향상
			  번역 오버헤딩이 필요없다?
	-> 단점 : 사람이 읽기 어렵기 때문. 기계어이기 때문에,디버깅 하기가 어렵고 어디서 에러인지 알아차리기가 어렵다.
	-> 바이너리 형식으로도 메타데이터를 포함시킬 수 있다.
	-> 우리는 이런 형식을 사용해야한다. 성능이 중요하기 때문에
	-> MMORPG에서 사용
- 메타 데이터가 없는 형식
	-> 장점 : 사람이 알아보기 쉽고 가독성 ↑
	-> 단점 : 오동작을 일으키기 쉽다.
- 메타 데이터가 있는 형식
	-> 한 번에 어떤 것인지 알기 쉽게 설명을 덧붙여서 보내는 형식	
								   ---> = 메타 데이터
	-> 장점 : 오동작을 일으키지 않는다, 하위 호환성 측면에서 유리하다.
	-> 단점 : 데이터의 크기가 더 커진다, 사용자의 편의성과 성능을 뒤바꾼다.
	-> 모바일앱에서는 메타 데이터 방식이 유리 : 대부분의 모바일앱의 서버는 웹서버 시스템을 사용하기도 함

** 오버헤드 (overhead) : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등

* 네트워크 주소 변환
우리가 인터넷을 통해서 데이터를 주고 받을 때 
클라이언트 ----------------------- 서버
		  connect(32bit 주소 정보)
					-> 컴퓨터가 40억대 이상은 연결할 수 없다. 
					하지만 지금은 60억대 이상 연결되어 있어서 IPv6가 개발됨
- 공유기(NAT 라우터) : IP주소 하나를 여러대의 기기가 연결될 수 있도록 만들어 주는 역할
	-> 129.7.5.1 : 포트번호
		-> 해당하는 포트 번호에 전달을 해주는 역할을 라우터가 함
	-> NAT : network address translation
	-> 192.168.0.5 라우터 내의 연결된 기기의 IP주소? 전세계에서 이런 번호를 수십만대 이상이 사용 꼼수임.
	-> 맨 끝단에 있는 공유기의 주소를 알아야하는데 이것을 알아내기가 어려움
	-> 서버를 내 집에서 띄우고 학교나 친구 집에서 접속을 하려면 굉장히 복잡한 절차가 필요하다.
	-> 서버를 공유기 밖으로 빼놓고 직접 접속해서 연결을 한다.
	-> 서버 대여업체에서 서버를 빌려쓴다...?
	

======================================================================
							191002
======================================================================
epoll -> connect와 accept에서도 I/O 기능을 사용 가능
요즘에 리눅스에서 쓰는 회사에서는 epoll대신 asio를 사용한다.

1:n서버 클라이언트가 아무때나 접속하고 아무때나 종료할 수있다.
클라이언트가 접속하는 즉시 accept한다.

서버가 클라이언트로 패킷을 한가지가 아니라 여러패킷(무브, 채팅, 이펙트)을 묶어서 보낼 때 어떻게 해야하나?
1. send를 3번
	-> 운영체제를 3번 호출해야하기 때문에 낭비이다.
	-> 버퍼를 크게 만들어 한 번에 보낸다.
		-> 메모리를 차지하고, 복사하느라고 시간이 많이 걸린다.
		-> 하지만 운영체제를 호출하는 것보다는 오버헤드가 덜걸린다. 
		-> 그렇지만 포인터를 참조하면 메모리 카피도 필요없어서 굉장히 효율적이다.


RIO -> 잘 사용한다면 IOCP보다는 성능이 더 좋을 수도

======================================================================
							191009
======================================================================
IOCP는 성능 때문에 쓰는 것인데 멀티 스레드를 사용하는 것이 좋다.



======================================================================
							191017
======================================================================
물리적 서버의 유지비용이 낮은 이유 : 컴퓨터 한 대당 운영체제 하나를 구동하기 때문에
클라우드 서버는 가상 머신 여러개를 돌리기 때문에 가상 머신이 제대로 동작하는지 검사및 감시를 해야하고,
관리가 까다롭기 때문에 유지비용이 높다.
서버를 빨리 철거할수록 비용을 빨리 축소할 수 있다.
서버가 대박이나면 증설을 해야한다. 물리적 서버는 컴퓨터의 대수를 늘려야하기 때문에 자동 스케일 아웃이 아니라 수동 스케일 아웃이다.
클라우드는 자동 스케일 아웃이 가능하다. 미리 서버 증설 스크립트를 짜고 서버를 증설할 때 그 스크립트를 실행하면된다. 관리 프로그램이 서버를 복사하여 증설을 한다.
처리 속도의 균일성 : 패킷이 들어왔을 때의 처리 속도, 물리적 서버는 패킷이 들어올 때 즉시 처리를 하기 때문에 빠르다. 
					 클라우드 서버는 어떠한 가상서버에 들어온건지 확인을 하는 단계적으로 검사하는 작업이 있어서 처리 속도가 비교적 느리다. 클라우드의 운영체제는 1년 365일 실행이 되는 것이 아니라 시분할로 나뉘어서 실행을 한다. 그래서 패킷이 들어와도 즉시 처리가 불가능하고 딜레이가 발생되어 생각보다 성능에 많은 영향을 끼친다.
장애 처리 : 물리적 서버는 하드디스크, 프로그램 등등을 복사하여 새로 셋팅하고 돌려야하느라 숙달된 관리자가 해도 장애처리 속도가 느리다. 또한 예비 컴퓨터가 없을 시 예비 컴퓨터가 생길때까지 장애 처리하기가 힘들다.
			클라우드 서버는 가상머신을 복사하는 시간밖에 걸리지 않는다.
---> 처리 속도의 균일성을 제외한 나머지는 클라우드 서버의 성능이 훨씬좋기 때문에 클라우드 서버를 많이 사용한다.
	리니지는 물리적 서버로 구성되어있다.

게임회사에서는 PaaS나 SaaS를 사용 X, 서버 프레임워크를 클라우드 서비스에서 짜는 것이 아니기 때문이다.
SaaS : 데이터베이스를 사올 수가 있다.

구글 스타디아 : 모든 역할을 서버에서 하기 -> 게임 로직 연산, 화면 렌더링(그래픽 있음), 화면 송출(비디오 스트리밍)

엔터폴레이션 데드레커닝 인터폴레이션

======================================================================
							191023
======================================================================
네트워크 동기화 -> latency 시간지연을 클라이언트 프로그래머가 해결

클라이언트		서버
입력			Obj
ObjectUpdate		update			
Render	<-------------	Result

			Move
클라이언트 ---------------> 서버				클라이언트 1 : network 부하 1				전체 클라이언트 수의 제곱 = 네트워크 부하
		  <---------------					클라이언트 2 : network 부하 4		
		   MoveOk							클라이언트 3 : network 부하 9


네트워크 부하가 10000부터는 버티기 힘들어하는데 동접이 5000명이면 네트워크 부하는 25000000인데 서버가 너~무 견디기 힘들어한다.
그래서 가시영역내에서 있는 플레이어의 정보만 전송해도된다. -> 시야처리 

배그는 가시영역처리를 한다. 스타크래프트1는 가시영역처리를 안하지만 스타크래프트2는 가시영역처리를 한다. 왜냐하면 유닛의 개수가 플레이어 한 명당 몇 백개이기 때문에.
-> 그럼 아마 졸작할때에 몬스터가 몇백마리면 가시영역처리를 하는게 맞을듯.

시야처리를 하기 전 : n클라 x nPlayer				ex) n = 5000, k = 10이면  시야처리 전 = 25000000, 시야처리 후 = 50000
시야처리를 한 후 : n클라 x k						

락스텝 동기화
-> 레이턴시에 굉장히 민감하다
	-> 마지막 클라이언트가 모든 클라이언트의 입력을 받고난 후 프로그램처리를 한 후 다시 모든 클라이언트에 전송을 하기 때문에
	-> 만약 핑이 느린애가 있다면 모든 클라이언트가 영향을 받는다
미래시간 산정법 = 현재 시간 + 왕복 레이턴시(RTT) / 2 + 임의의 일정값 
대부분 P2P 방식의 실시간 전략게임 등에 많이 사용
락스텝 동기화에서 레이턴시를 감추기 위해 얼렁뚱땅 테크닉을 사용한다.

실제 레이턴시 줄이기
1. TCP대신 UDP를 사용한다. UDP가 TCP보다 속도가 빠르기 때문에, UDP는 순서 뒤섞이거나 데이터를 가끔가다 잃어버리는 것에대한 처리를 하지 않기 때문에
2. 똑같은 양의 데이터를 보낸다 하더라도 가급적 적은 수 의 패킷으로 보낸다.	10byte짜리 10번 보내는 것보다 100byte 하나를 보내는게 훨씬 오버헤드가 적다.
3. 클라이언트와 서버 간 통신(C/S 네트워킹)과 클라이언트끼리 직접 통신(P2P)하는 것을 더 선호한다.

공유기를 사용하면 P2P지원이 안된다.
모바일 게임은 P2P가 안된다. P2P가 되면 토렌토든지 네트워크를 직접 거치지않은 프로그램을 사용할 수도 있어서 돈을 못벌어서...

게임 플레이 이외의 네트워킹
로그인 과정에서 클라이언트와 서버가 대화하는 주요 절차
1. 로그온 요청 메시지를 서버로 전송 
	-> 클라이언트는 서버에 접속
2. 서버는 파일이나 데이터베이스에 해당 유저의 ID와 비밀번호를 받아서 식별한다.
	-> 아무나 아무 아이디로 플레이할 수 없다.
3. 식별 결과, 즉 로그온 처리 결과를 클라이언트에 통보한다.
4. 클라이언트 통보를 하면서 플레이어 정보를 데이터베이스에서 로딩 해서 게임 서버 메모리에 보관한다.

코어 개수 = 스레드 개수

스레드 생성은 오버헤드가 크다

서버와 클라이언트로 분류하는 이유는 해킹을 막기위해서다.
해킹유형
1. 크래킹 : 다른 사람의 ID와 비밀번호를 도용하거나 비밀 정보를 보는 것, 서버에 저장된 데이터를 훼손 하거나 훔치는 것
2. 치트 or 조작 : 내 능력치를 비정상적으로 높이거나 다른 사람의 플레이를 망가뜨리는 것

컴퓨터가 해킹당하면 암호화가 소용이 없다.
-> 바이러스, 트로이 목마

구문인젝션 -> 특수문자로 예방


클라이언트 : windows10
서버 : window server 2018

서버에서 검사해서 해킹을 해봣자인 상태로 만들어 놓는다.
아이템사용, 벽뚫기 등등

신경써야하는 구현 컨텐츠 
1. 지형 자료구조의 크기 및 검색 속도
2. 충돌의 Mutithread safeness
	- PC간의 충돌
	- PC NPC간의 충돌
3. Drop Item으로 인한 부하
	- Item Drop
	- 사체 루팅

게임 서버 구현 기본 이슈
1.NPC AI 성능
	- 길 찾기
	- Script
2. Contens 생산성
	- 전투, 퀘스트, 스킬

Mutithread Issue			
1. 충돌
2. Item rooting
	- 동시성 제어

BroadCasting문제
- 클라이언트에서 게임 월드의 상황을 볼 수 있으려면?
	-> 서버가 접속한 아바타는 물론 다른 Object들의 상태도 보여 주어야 함

