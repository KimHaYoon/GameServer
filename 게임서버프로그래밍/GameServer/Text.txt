중간 20% 기말 25% 숙제 15% 턴프로젝트 30% 출석 10%

======================================================================
																	190904
======================================================================
CH1. 멀티스레드 프로그래밍

프로그램 ---실행---> 프로세스 (운영체제가 관리)
스레드 (= context) : 프로세스를 이루는 구성요소? 
Context : 실행 문맥, 맥락
	-> CPU 내부 상태

프로그램 1000개 작업이 있을 때 멀티스레드 프로그래밍은 1000개의 작업을 두개의 작업으로 나눈다.
-> 500개 작업씩 2개 (thread1, thread2)
멀티스레드 프로그램 -> 작업을 나누어서 별도의 여러개 스레드, 코어에서 수정

프로그램을 2개를 만들어서 할 때 통신 및 동기화가 필요없다면 그렇게해도 무관하지만 자원을 주고받는다면
통신, 동기화 과정이 꼭 필요하다.

IPC (Inter Procsess Communication)

Process
segmentation -> segment
code : 기계어 실행코드
data : 전역변수
heap : 동적할당 (new delete, malloc free)
stack : 지역변수, 함수, 함수파라미터

멀티 스레드일 때
thread0						|					thread1
code							|					X
data							|					X
heap							|					X
stack0						|					stack1

0번 스레드가 동적할당을 했을 때 1번스레드에서는 그 동적할당 한 자원을 아예 쓸 수 없는 것이 아니라 주소를 알면 쓸 수 있다.
스택에 있는 데이터는 공유를 할 수없다. 함수를 호출하면 지역변수가 생성이되는데 함수를 리턴하면 지역변수는 날아간다.
그렇기 때문에 공유가 되면 읽고 쓰던 데이터가 날라갈 수 있는 위험성이 있기 때문에 공유자체를 하면 안된다.

동시접속자 수가 1000명밖에 안되는 이유는 게임서버가 느려서
1. 잘못된 자료구조, 알고리즘을 사용하여 -> 좋은 자료구조, 알고리즘으로 대체
2. I/O 작업을 해서 -> 좋은 하드웨어를 산다, I/O 데이터 량을 줄이거나 횟수를 줄인다, 비동기

CPU가 느리면 잘 짠 서버를 실행해도 느리다.

1. 큰작업, 작은 작업 나눠서
2. 여러가지 작업들은 메모리? 
3. 멀티 스레드
4. 보기쉽게(OUP)? 먼말이냐 이건

Thread
1. Kernel level thread
	-> OS 관리
2. User level thread
	-> program 자체 관리

운영체제를 통해서
- window.h
 create thread				=> 너무 오래된 방식

--> 현재는 C++ 11를 통하여 생성

#include <thread>
std::thread 라는 클래스가 있는데 이 클래스의 객체를 만드는 것이 스레드를 생성하는 것
main()
{
	std::thread t1{함수포인터};
	std::thread t2;
}

운영체제
멀티 프로세서
동기화
	올바른 동기화를 위해서는 lock(), unlock(), 세마코어, 모니터, 데드락 등등이 필요하다
										------------
										#include <matrix> std::matrix my_lock
										my_lock.lock()
	



======================================================================
																	190905
======================================================================
1. 멀티쓰레드
게임서버
- 정확성 ->  NO BUG
- 성능	-> 렉이 없다
			-> 빠른 반응					
			=> 성능을 높히려면 멀티쓰레드를 사용해야한다.

2. 네트워크
게임 서버 : 온라인 게임 서버
					-> Network
					-> 넷기초 - 넷겜플 - 겜서버프로그래밍

3. 네트워크 프로그래밍
네트워크 기초
								서버	---		클라이언트
리소스를 가지고 있음						리소스를 요청하는 쪽				리소스를 서로 주고 받으면서 네트워크 프로그래밍 활동을 함	

OSI 7계층 X
TCP/IP 프로토콜 -> 4계층 
어플리케이션 레이어

4. 컴퓨터 네트워크 데이터
FILE I/O 
- C 
	- open - read, write - close

Network -> I/O
* I/O의 특징 : 운영체제가 관리 
- FILE I/O와 거의 유사
	- connet - send, recv - close

3번 보낸다고 3번 맞춰서 받아주지는 않는다.
전달되는 순서는 반드시 지켜지는데 묶어서 보내든 풀어서 보내든 랜덤으로 보낸다.

네트워크 데이터의 양을 고려해서 서버를 설계해야한다.
데이터를 조금씩 보내면 처리해야할 데이터의 크기가 작아서 처리가 빨리 되기 때문에 성능이 향상이 된다.
그때 고려해야할 방식을 헤더 방식
ex) 100byte를 보낼 때 100byte를 한번에 보내던지 10byte씩 10번 보내던지 두가지의 방법이 있다면 10byte씩 10번 보내는 것이 네트워크 성능이 향상될 수 있다.
		? 데이터를 한방에 보낼 때 여러번 자주 보내는 것 보다 좋다. 

메세지 형식
클라이언트 -------------> 서버														-- 디비
이동방향									채팅 (누구한테, 뭐라고)
공격											다음 위치, 공격후 상태	(스킬? 등등)
채팅											인벤토리	

네트워크로 주고 받는 것은 2진수 이다. byte
총알의 발사된 위치 종류 등등 알려줘야한다. 그래서 맨앞에 타입이 들어가야하고 크기가 들어가야 한다.
데이터 묶음 하나하나를 패킷이라고 부른다.

단편화 : 매우 긴 스트림을 송신 할 때 운영체제에서 이를 IP 패킷의 크기 제한에 맞추어 여러 조각을 내는 것
-> 스트림을 패킷으로 조각내고 패킷을 다시 스트림으로 복원

