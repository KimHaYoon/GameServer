중간 20% 기말 25% 숙제 15% 턴프로젝트 30% 출석 10%

======================================================================
																			190904
======================================================================
CH1. 멀티스레드 프로그래밍

프로그램 ---실행---> 프로세스 (운영체제가 관리)
스레드 (= context) : 프로세스를 이루는 구성요소? 
Context : 실행 문맥, 맥락
	-> CPU 내부 상태

프로그램 1000개 작업이 있을 때 멀티스레드 프로그래밍은 1000개의 작업을 두개의 작업으로 나눈다.
-> 500개 작업씩 2개 (thread1, thread2)
멀티스레드 프로그램 -> 작업을 나누어서 별도의 여러개 스레드, 코어에서 수정

프로그램을 2개를 만들어서 할 때 통신 및 동기화가 필요없다면 그렇게해도 무관하지만 자원을 주고받는다면
통신, 동기화 과정이 꼭 필요하다.

IPC (Inter Procsess Communication)

Process
segmentation -> segment
code : 기계어 실행코드
data : 전역변수
heap : 동적할당 (new delete, malloc free)
stack : 지역변수, 함수, 함수파라미터

멀티 스레드일 때
thread0						|					thread1
code							|					X
data							|					X
heap							|					X
stack0						|					stack1

0번 스레드가 동적할당을 했을 때 1번스레드에서는 그 동적할당 한 자원을 아예 쓸 수 없는 것이 아니라 주소를 알면 쓸 수 있다.
스택에 있는 데이터는 공유를 할 수없다. 함수를 호출하면 지역변수가 생성이되는데 함수를 리턴하면 지역변수는 날아간다.
그렇기 때문에 공유가 되면 읽고 쓰던 데이터가 날라갈 수 있는 위험성이 있기 때문에 공유자체를 하면 안된다.

동시접속자 수가 1000명밖에 안되는 이유는 게임서버가 느려서
1. 잘못된 자료구조, 알고리즘을 사용하여 -> 좋은 자료구조, 알고리즘으로 대체
2. I/O 작업을 해서 -> 좋은 하드웨어를 산다, I/O 데이터 량을 줄이거나 횟수를 줄인다, 비동기

CPU가 느리면 잘 짠 서버를 실행해도 느리다.

1. 큰작업, 작은 작업 나눠서
2. 여러가지 작업들은 메모리? 
3. 멀티 스레드
4. 보기쉽게(OUP)? 먼말이냐 이건

Thread
1. Kernel level thread
	-> OS 관리
2. User level thread
	-> program 자체 관리

운영체제를 통해서
- window.h
 create thread				=> 너무 오래된 방식

--> 현재는 C++ 11를 통하여 생성

#include <thread>
std::thread 라는 클래스가 있는데 이 클래스의 객체를 만드는 것이 스레드를 생성하는 것
main()
{
	std::thread t1{함수포인터};
	std::thread t2;
}

운영체제
멀티 프로세서
동기화
	올바른 동기화를 위해서는 lock(), unlock(), 세마코어, 모니터, 데드락 등등이 필요하다
										------------
										#include <matrix> std::matrix my_lock
										my_lock.lock()
	




